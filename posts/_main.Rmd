---
title: "Packages & Reproducibility: Install what you need, attach what you want"
author: Mike DeCrescenzo
description: "A comment on conditionally installing, attaching, and not attaching packages for reproducible R scripts"
date: '2018-05-30'
slug: reproducible-packages
categories: ["Methods"]
tags: ["Reproducibility", "R"]
comments: no
showcomments: yes
showpagemeta: yes
draft: false
---

*(Note: An earlier version of this post referred to "loading" packages when I really meant "attaching." Thanks to [Thomas Leeper](https://twitter.com/thosjleeper/status/1001859564113924096) for the clarification.)*

---

When we distribute R code (for publication/replication archives, on Github, through blog posts, etc), we like the code to run smoothly on someone else's machine. Packages present a nominal problem because different users have different packages installed on their computer. Ideally the script we are distributing should install dependencies without the redundancy of re-installing packages that a user already has installed. 

To solve this, many users conditionally install packages using `require()`; if a package fails to attach, it is installed. Supposing that we want to use a package called `pkg`...

```{r, include = FALSE}
# future chunks are not evaluated
knitr::opts_chunk$set(eval = FALSE, collapse = TRUE)
```

```{r}
# if require() succeeds, package is attached
# if require() fails, package is installed
if (require("pkg") == FALSE) {
  install.packages("pkg")
}
```



We see often see this in (for example) package ReadMe files on Github. But for distributing bigger projects, the approach has two shortcomings.

1. Sometimes we require a package, but we don't want to attach it fully. We may only need it for a function or two, or we want to prevent [clashing function names](https://github.com/r-lib/conflicted) in projects that use many packages, and so we prefer to use the `pkg::function()` grammar instead of attaching every package with `library()`.
2. If we require several packages for a large project (like a replication archive for a published journal article), including code to install all packages ends up unsightly and repetitive (but functional, to be fair).

This post discusses a straightforward strategy for addressing this.


## Check for installed packages without attaching them

Rather than use `require()`, which has the side-effect of attaching an installed package, we can look for installed packages using the output from `installed.packages()`. In particular, the function should return an array whose rownames contain the names of our installed packages. 

```{r, eval = TRUE}
head(rownames(installed.packages()))
```

Using these rownames, we can check for installed packages without attaching those packages incidentally. Just create a character vector of required packages and cross-reference those names with the list of installed packages.

```{r, eval = TRUE}
c("ggplot2", "beepr", "some_other_package") %in% rownames(installed.packages())
```


## Install what we need, attach what we want

The structure laid out above can be augmented to install missing packages. Just use a little bit of indexing:

```{r}
# vector of requirements 
requires <- c("pkg_1", "pkg_2")

# evaluates to TRUE if not already installed
to_install <- (requires %in% rownames(installed.packages()) == FALSE)

# install missing packages
cloud_url <- "https://cloud.r-project.org/"
install.packages(requires[to_install], repos = cloud_url)
```

Because we never call `require()`, we can attach (or not attach) whichever packages we want with subsequent `library()` commands. (We could have also used `requireNamespace()` to check for packages.)



# Coda: on the use of `library()` vs `require()`

Thinking back to this [oft-cited post by Yihui Xie](https://yihui.name/en/2014/07/library-vs-require/), the takeaway was that we should only be using `require()` to...

1. conditionally install packages, or 
2. implement "bonus-features" that may enhance a package or function but that aren't strictly necessary

In reference to [1], I think we can (and should) flatly avoid `require()` in any situation where we need a package but don't want to attach it. For me, this is basically all of my research projects, and I think many other users will find themselves in a similar boat. As long as `require` attaches a package in the process of checking for it, `require` gives unintended and unnecessary side-effects.

In reference to [2], it's a little funny that we got to a point where we would only use a function called `require` for features that are strictly not required. It's quite the contradiction. In a parallel universe we might have named the function something squishier like `suppose()`. At any rate, the chief reason to use `require` in this case---it returns logical output---isn't necessary either, since `library()` has a `logical.return` argument that achieves the same objective.


# Thanks for reading

Feel free to [get in touch](https://www.twitter.com/mikedecr) with comments, links to related posts by others, packages that implement similar features, and so on. 





<!--chapter:end:2018-05-26-reproducible-packages.rmd-->

---
title: "Great Hugo themes (that I did not pick)"
author: Mike DeCrescenzo
date: '2018-09-23'
slug: hugo-themes
categories: ["Misc"]
tags: ["R", "blogdown", "Hugo"]
comments: no
showcomments: yes
showpagemeta: yes
draft: false
---

I just finished a major website overhaul. While it took only about one day of work, I've had my eyes open for a new [theme](https://themes.gohugo.io/) for [Hugo](https://gohugo.io/) for a while.

I mean, a *while*. I would download a theme, give it a 15-minute test run offline, and decide that it wasn't for me. I did that maybe a dozen times.[^bdown]

[^bdown]: The only way I was able to test themes so efficiently was thanks to the amazing [blogdown](https://bookdown.org/yihui/blogdown/) package for R.

But this is mainly my fault. I am a bad combination of *picky* and *unskilled* with websites and web design, which made me a fickle chooser throughout the process. So to make up for that fickleness, I wanted to acknowledge and promote some of the Hugo themes that I really liked, but ultimately did not choose for my site. 


## Goa

I previously used [Goa](https://themes.gohugo.io/hugo-goa) for my site. It is simple, sensible, and easy to modify. 


## Introduction

One of two themes by [Vicky Lai](https://vickylai.com/) that I will promote. [Indroduction](https://themes.gohugo.io/hugo-theme-introduction/) has a bold design and a layout that is focused on the landing page, which I enjoyed. I especially loved the "About" section. 


## Call Me Sam

The other Vicky Lai theme. If "Introduction" was bold, I would say that [Call Me Sam](https://themes.gohugo.io/hugo-theme-sam/) is *brave*. I don't trust that my description will do it justice; better to [see for yourself](http://vickylai.com/call-me-sam). 


## Cocoa Enhanced

[Cocoa Enhanced](https://themes.gohugo.io/cocoa-eh-hugo-theme/) is crisp and clean. Its type design is opinionated but flexible. I was most tempted to use this theme. 


## Coder

I must include [Coder](https://themes.gohugo.io/hugo-coder/) because it is the inspiration for the theme I ultimately chose. Why do I like it? The simple landing page. The navigation bar is out of the way but present. The backend tension between "section" pages and "post" archives (one of the more difficult aspects for a newbie working with Hugo) is easily to navigate.


# Let me know about your theme that you really like

Perhaps on [Twitter](https://twitter.com/mikedecr)


<!--chapter:end:2018-09-23-hugo-themes.rmd-->

---
title: "A Visualization of Partial Effects in Multiple Regression"
author: Mike DeCrescenzo
description: "Partial effects without high dimensions"
date: '2018-10-19'
slug: viz-partials
categories: ["Methods"]
tags: ["Visualization", "R"]
comments: no
showcomments: yes
showpagemeta: yes
draft: true
# nature:
#       beforeInit: "https://platform.twitter.com/widgets.js"
---



```{r, include = FALSE}
# cache, collapse
knitr::opts_chunk$set(cache = TRUE, collapse = TRUE)
```

```{r}
print("ello")
```

<center>
  <blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Helpful animated <a href="https://twitter.com/hashtag/dataviz?src=hash&amp;ref_src=twsrc%5Etfw">#dataviz</a> showing what happens to the slope of one coefficient in a model when controlling for other variables in multiple regression<br><br>(<a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> code: <a href="https://t.co/yhVLj325Oh">https://t.co/yhVLj325Oh</a>) <a href="https://t.co/2foYfXDo28">pic.twitter.com/2foYfXDo28</a></p>&mdash; ðŸŽƒ Andrew Heiss, scary PhD ðŸ¦‡ (@andrewheiss) <a href="https://twitter.com/andrewheiss/status/1052978108255498240?ref_src=twsrc%5Etfw">October 18, 2018</a></blockquote>
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<center>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Ok fixed. <br><br>In this fig, y is (beta * humidity), plus the regression residual. This is equivalent to starting with the fully estimated regression and subtracting out terms for every other covariate <a href="https://t.co/fLs4WxHTaK">pic.twitter.com/fLs4WxHTaK</a></p>&mdash; Michael DeCrescenzo (@mikedecr) <a href="https://twitter.com/mikedecr/status/1053028075170975744?ref_src=twsrc%5Etfw">October 18, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>


<center>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">omg this is astounding! Do you have the code for it?</p>&mdash; ðŸŽƒ Andrew Heiss, scary PhD ðŸ¦‡ (@andrewheiss) <a href="https://twitter.com/andrewheiss/status/1053031575770718208?ref_src=twsrc%5Etfw">October 18, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<!--chapter:end:2018-10-19-partialling-out.Rmd-->

