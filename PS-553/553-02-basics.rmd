---
title: "Day 0: R Basics"
description: "Getting R up and running. READ BEFORE CLASS."
author: "Michael DeCrescenzo"
date: '2017-12-01'
slug: 553-basics
categories: ["R", "PS553", "Teaching"]
tags: []

draft: true
---

# sarah

- script files
  + what is it
  + editing
    * simpler ones: Textmade, Notepad++, 
    * Intermediate: Sublime, 
    * Advanced: Emacs w/ ESS, Vim
  + how
    * plan ahead
      - outline project
      - pseudocode
      - search online
      - reuse code
    * identify tools and packages
    * modular documents
    * comments
    * saving work
  + what to include
    * metadata: title, author, data
    * directory setup
    * packages
    * data
    * analysis
    * output (graphics, tables, generated quantities)
- Commenting code
  + notes to self
    * don't overdo it. Better for *why* something is happening
    * Try to write code that has obvious effects. When you can't, commenting the *how* can be more useful. *Especially if you need to depend on a user-defined function (gender gap example)*
  + If you have an ID, program some comment snippets

```{r}
# ----------------------------------------------------
#   big heading
# ----------------------------------------------------

# --- subheading -----------------------

# comment
```

- what is pseudocode
  + planning something without code, making it readable
- save your shit
  + back up data online
  + now would be a good time to get started on learning version control (git, mercurial, (but use git))
  + `save.image()` for saving everything in workspace memory. DON'T do this willy nilly. You should be able to recreate everything using script file. But for long things (big data), it can be useful.
  + OR just save data that took a while to construct
    * *file 1: load raw data, clean data, save clean data*
    * *file 2: load clean data, run lengthy simulations, save simulation output*
    * *file 3: load simulation output, analyze simulations...*
  + just don't save over your raw data
- Working directory
  + have projects live in their own folders
  + set directory to the "root" of that folder
  + reference other files within it
    * *don't go all the way into the data, tbh*
    * *makes saving things to your output folders more difficult, because you have to navigate backward*
  + *show a project example*
  + *maybe do this in two parts, start by constructing a folder with R/ and data/, but don't talk about output just yet*
  + `getwd()`, `setwd("/Users/me/Dropbox/myproject")`, `setwd("C:/Me/Dropbox/myproject")`
- installing packages
  + R keeps its functions in packages/libraries
  + several already installed
  + you can more, for different needs
  + dependencies
  + masking!
    * `::` to get around that
- help files
  + `?` and `??`
  + works for function names and package names
- Interfacing
  + calculator
  + creating objects
    * some simple functions
    * order of operations
    * strings
    * integer and real sequences
    * matrices, binding vectors, arrays
  + indexing
    * `[1], [c(1, 3)], [1, 2], [!1], [nrow(df], ncol(df))]`
  + removing data
    * `ls()` and `rm()`
    * *put `rm(list = ls())` in the top*
  + data type
    * `class()`
    * `str()`
    * logical, numeric (integers and doubles) character, factor
- functions
  + in general, what are they


# Installing R

UW--Madison students click [here](https://mirror.las.iastate.edu/CRAN/) to download R for your operating system (if you haven't already). 

A little bit about what's going on here: R is open source and is distributed from various ["mirrors"](https://en.wikipedia.org/wiki/Mirror_website), which are clone websites that contain essentially identical information. The CRAN (Comprehensive R Archive Network) hosts these mirrors [all over the world](https://cran.r-project.org/mirrors.html). It is generally recommended that you install R (and related software like R packages) using mirrors in nearby locations. Any mirror in the U.S. should be fine for our purposes. The link at the top of this section uses the Iowa State University mirror.

Once R is downloaded, make sure that it is fully installed.



# Using R

The most essential part of using R is the *console*. This is where results of all commands are displayed. There is a prompt at the bottom of the console where commands can be submitted directly.

<center>
  <img src="img/r-console.png" alt="R console" style="width: 80%;"/>
</center>

Although you can type commands directly into the console, most commands should be written in a *script file*. Script files serve the same purpose as they do in Stata; they provide a record of all commands you want to run in your analysis. This lets you replicate your analysis the next day, the next week, the next year, or whenever (presuming your code does not become obsolete with future package versions, for example).



# Open a script file

Use whatever program you desire to open a script file. The basic R GUI application has a script editor that can be accessed using the `File` menu or a keyboard shortcut. Many R users prefer to manage R projects using [Rstudio](https://www.rstudio.com/products/rstudio/), an [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) that provides several tools for interacting with R. Windows users may find Notepad++ or TextMate to be useful text editors. Advanced programmers may use Emacs or Vim with some package (such as ESS for Emacs) to speak to the R console. I would recommend any external editor that can send commands to the R console and, as you become more comfortable with R, that contains some keyboard shortcuts for creating fast R code. Rstudio comes standard with many such shortcuts.

Personally, I prefer to edit R script using the [Sublime Text](https://www.sublimetext.com/) editor and the [R-Box package](https://packagecontrol.io/packages/R-Box).^[Package control does not come default with Sublime Text, but it is a universal component of any Sublime user's experience. Instructions for installing and using Package Control can be found [here](https://packagecontrol.io/installation).] Sublime has a nice system for editing custom keyboard macros for any language you frequently use, which I use liberally.^[Individuals who are already comfortable with Sublime should feel free to raid my custom settings, which can be obtained through my [Github page](https://github.com/mikedecr/sublime-user-folder).]

Script files should begin with some description of the script. You can include comments (text that will not be executed as R commands) after the `#` symbol. For example, your script file for this lesson might contain some comments at the top like...

```{r}
# ------------------------------------------------------------
#  PS 553: statistical computing for political science
#  Lesson 1: Basics of R
# ------------------------------------------------------------
```

Although a script file can be imperfect while a project is being developed, a well-written script file for a finished project should be organized, easy to read, and run from top to bottom without any errors. This is important for ensuring that you can retrace the steps of your analysis.

Save this file. In your `ps553` folder on your computer (which you should have...), create a section for R containing a "lessons" folder. Save this document in `553/R/lessons/`.^[This notation signifies a folder directory pathway. Slashes indicate folders.] 




# Executing commands

Just like Stata, the R interface is a REPL---that is, Read-Evaluate-Print Loop. That means R processes commands one at a time without the need to pre-compile any code (compilation essentially happens during execution).^[Interestingly, this makes R slower than languages that require pre-compilation---such as C++, which is the basis of the Stan language for writing Bayesian models. Much of Bayesian analysis is waiting for models to compile (and then waiting for the sampler to run...lots of waiting in Bayes).]

Just to demonstrate some basic R behavior, let's run a few commands.

First, R works as a calculator. It can handle mathematical expressions. Paste or type the following lines of code DIRECTLY into the console.

```{r, eval = FALSE}
1 + 1
2 + 2
100 * 2
500 / 4
```

You will notice that the results of each calculation will print beside a little `[1]`. Ignore this for now; we will explain it later.

Now take the above block of code and paste the commands into your script file. Try to run the commands from the script file using a keyboard shortcut. Most computers and interfaces use `super + enter`, where `super` refers to `Ctrl` on PCs or `Cmd` on Macs. Windows machines may use a different shortcut, such as `Ctrl + R`. Take this opportunity to look up the appropriate keyboard shortcut on your own, *before coming to lecture!* :-)



# Everything is an Object

We don't usually manipulate mathematical expressions this atomically in R. Instead we treat data as variables. Before we jump into that, we should explain how R treats variables. 

In R, everything is an object. I can store an arbitrary value as a variable, which is an object. A text string can be an object. An entire dataset. A variable within a dataset can be thought of as an object within another object. It's all objects. This makes R very flexible, although some object manipulations are obviously out of bounds (can't add `4 + "fish"`, for example).



# Variables

We can store and manipulate variables in R. Just as how in math the expression $x + 4$ can take different values depending on the value of $x$, we can do similar things with R. 

First, we'll "assign" a value to a variable using the assignment operator `<-`. The `<-` is a combination of a less-than sign `<` and a hyphen `-`.

For example,

```{r}
x <- 5
```

Now the variable `x` has the value of `5`, which is to say, `x` and `5` now mean the same thing! 

We can display the contents of any object by simply typing the object name. Print out `x`...

```{r}
x
```

...and we get back a `5`.

Do some math with `x`...

```{r}
x + 4
```

You can read the `<-` operator as "gets." So in the above example, `x` "gets" the value of 5. For simple expressions, `<-` can mean "equals," but as we begin working with more complex objects (such as the results of a statistical model), saying "equals" in your head becomes a little more difficult to justify.


# More variables: vectors

We can assign a series of values to a variable. One way to do this in R is the `c()` function. The `c()` function will bind several elements into one variable, as long as the elements can be coerced to be the same data type (numeric, factor, string, etc). We will return to the concept of *data types* later.

```{r}
y <- c(2, 4, 6)
y
```

If you wrap an assignment inside of parentheses, the result will print at the same time that values are assigned.

```{r}
(y <- c(2, 4, 6))
```

We can use multi-element variables to do math on the entire variable at once. Just as we could do real math...

$\begin{align*} 2 \times \begin{bmatrix} 2 \\ 4 \\ 6 \end{bmatrix} &= \begin{bmatrix} 4 \\ 8 \\ 12 \end{bmatrix}\end{align*}$

we can also do similar things with vectors in R.

```{r}
2 * y
y * y
```


## Indexing

It is possible to access the elements of a variable using *indexing* notation. R uses square brackets to select a given element in a variable. Using the variable `y` from above, what are the first, second, and third elements?

```{r}
y
y[1]
y[2]
y[3]
```

Indexing notation is why the console prints a little `[1]` next to all results. It is indicating that the adjacent element is the first element. This becomes clearer if we were to print a long vector with many more elements---for example, a sequence of 100 draws from a standard normal distribution.

```{r}
rnorm(n = 100, mean = 0, sd = 1)
```

We could have two (or higher) dimensional objects. Let's make some simple two-dimensional objects:

```{r}
tall_m <- rbind(c(1, 2), 
                c(3, 4), 
                c(5, 6))
tall_m
```

(Notice how `rbind()` binds vectors together as rows.)

```{r}
wide_m <- cbind(c(1, 2), 
                c(3, 4), 
                c(5, 6))
wide_m
```

(And `cbind()` binds vectors as columns.)

We can still use indexing notation to access the data within these objects. We use the notation `object[a, b]`, where `a` indicates the row number and `b` indicates the column number.

```{r}
tall_m[2, 2]
wide_m[1, 3]
```

If we don't specify a row, R grabs every row. Here we leave the row unspecified but grab the second column.

```{r}
tall_m
tall_m[ , 2]
```

And if we don't specify a column, R returns every column. Here we specify the row but leave the column unspecified.

```{r}
wide_m[1, ]
```

**Note:** Although some languages are "zero-indexed" (meaning the first element of a variable is index position 0), R is "one-indexed." This makes more sense for statistical purposes, but may be different from other languages you have seen (for example C). Calling the 0'th element of a variable does not throw an error, however. Go figure.

```{r}
y[0]
```

**Another important note:** Indexing isn't something you will use much in the tidyverse, but it is important to be familiar with it for a few reasons. First, it has useful mathematical parallels, where $y_{i}$ is analogous to `y[i]`. This sometimes comes in handy for dealing with the results from statistical models. Additionally, you will encounter it when searching through message boards for R help, especially when you see someone do some kind of *logical selection*. What does "logical selection" mean, exactly? Well...


# Logic

Logic as a concept in programming is less daunting than it sounds. At it's core, what we're doing is dealing with `TRUE`s and `FALSE`s. An example to illustrate what I mean. We'll make a vector.

```{r}
(g <- 1:10)
```

We can ask R about things that are true and false about the values in the vector. For example, are the values greater than 5?

```{r}
g > 5
```

What happened here? The statement `g > 5` is a "logical," meaning that its underlying meaning is fundamentally `TRUE` or `FALSE`. R asks if `g` is greater than 5 for each element in `g`, and R returns an entire vector of logicals, each element corresponding to the original elements in `g`. 

We can do this kind of thing with several operators. Let's see them in practice.

```{r}
# g "is equal to" 5
g == 5

# g "is greater than" 5
g > 5

# g "is less than" 5
g < 5

# g "is greater than or equal to" 5
g >= 5

# g "is less than or equal to" 5
g <= 5
```

Relating this back to index notation, you will probably see R users online using indexing and logical evaluation to select observations from a dataset. For example, let's say I want to multiply `g` by 10.

```{r}
g * 10
```

And now let's say that I only want to do this for values of `g` less than 4. First I can limit my selection of `g` to the values I want...

```{r}
g[g < 4]
```

...and then do the operation I want.

```{r}
g[g < 4] * 10
```

This seems a little abstract right now, but here's how you may see others do this online. Let's say that I have a dataset of World Health Organization data, and I want to look only at the European data. You might see someone online limit the data like so.

```{r, eval = FALSE}
who[region == "Europe", ]
```

how to read...

The `tidyverse` uses other tools to do this kind of thing, which are way easier.





# Functions

Although you can perform simple operations on data in R (adding, multiplying, and so on), these get tedious for complex tasks. Sequences of operations can be simplified as functions. We have already seen some examples of functions, such as `c()` for making vectors. Here are some helpful ones. 

```{r}
# create normally distributed random noise
(x <- rnorm(n = 100, mean = 0, sd = 1)) 

sum(x) 
# number of elements in an object
length(x) 
# calculating an average by hand
sum(x) / length(x)  
# equivalent
mean(x) 

# variance
var(x) 
# variance by hand
sum((x - mean(x))^2) / (length(x) - 1) 

# standard deviation
sd(x)
sqrt(sum((x - mean(x))^2) / (length(x) - 1))
```


## Writing functions

## Local variables





# Packages



# Data types



# How R is similar to Stata

REPL



# How R is different from Stata


Open Source

Vectors

Functions

Interface

Syntax more complex but grammatically coherent




# R Style

Explicit is always better than implicit

Rely on permanent features of the data rather than happenstance features: Call something by a column name, not the column number



# Tips

Close R and re-run often

Comment styles

```{r}
# ----------------------------------------------------
#   Big heading
# ----------------------------------------------------

# --- small heading -----------------------

# small comments
```


