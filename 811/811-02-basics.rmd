---
title: Getting Started with R
description: "Getting R up and running"
author: "Michael DeCrescenzo"
date: '2018-01-02'
slug: "811-basics"
categories: ["R", "ps811", "Teaching"]
tags: []
---

# Objectives

This document describes how to get started with R and understand its basics. We discuss installing R, running simple commands, and some elementary programming concepts such as indexing, logic, and functions. We close with some higher-level discussion about the differences between R and Stata. 

**Note:** Although I promised concrete lessons, this one unfortunately has to be a little more "abstract" than others. This is because we exploring R's *general* behavior rather than a concrete application of R workflow. Luckily, this will be short, and we get much more concrete in future lessons. 

You should take this lesson slowly at first if you have not played with R before. Mess around with some of the code if it helps you understand what it's doing. If you encounter material that does not make sense, please take note of it so we can review it in class before progressing too far.


# How to read these lessons

Pages in this series contain code blocks that you can paste into R. Some of the code blocks are included with their results.

```{r, eval = FALSE}
"Code appears in blocks like this."
"You can paste this code directly into R."
```

```{r, echo = FALSE}
"Results appear on this page with two '##' signs"
```



# Installing R

If you have not set up R already, click [here](https://mirror.las.iastate.edu/CRAN/) to download R for your operating system (if you haven't already). 

A little bit about what's going on here: R is open source and is distributed from various ["mirrors,"](https://en.wikipedia.org/wiki/Mirror_website) which are clone websites that contain essentially identical information. The CRAN (Comprehensive R Archive Network) hosts these mirrors [all over the world](https://cran.r-project.org/mirrors.html). It is generally recommended that you install R (and related software like R packages) using mirrors in nearby locations. Any mirror in the U.S. should be fine for our purposes. The link at the top of this section uses the Iowa State University mirror.

Once R is downloaded, make sure that it is fully installed. You can run R using the GUI app (`R.app` on OSX or `Rgui.exe` on Windows), using the Rstudio application (which we discuss below), or as a program in your computer's command-line shell (which I do, for technical reasons).



# Using R

The most essential part of using R is the *console*. This is where results of all commands are displayed. There is a prompt at the bottom of the console where commands can be submitted directly. Yours won't be the same colors as mine, but it looks sort of like this:

<center>
  <br>
  <img src="img/r-console.png"  alt="R console" style="width: 80%">
</center>
<br>

Although you can type commands directly into the console, most commands should be written in a *script file*. Script files serve the same purpose as they do in Stata; they provide a record of all commands you want to run in your analysis. This lets you replicate your analysis the next day, the next week, the next year, or whenever (presuming your code does not become obsolete for some reason).



# Open a script file

Use whatever program you desire to open a script file. The basic R GUI application has a script editor that can be accessed using the `File` menu or a keyboard shortcut. Many R users prefer to manage R projects using [Rstudio](https://www.rstudio.com/products/rstudio/), an [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) that provides several tools for interacting with R. Windows users may find Notepad++ or TextMate to be useful text editors. Advanced programmers may use Emacs or Vim with some package (such as ESS for Emacs) to speak to an R console. I would recommend any external editor that can send commands to the R console and, as you become more comfortable with R, that contains some keyboard shortcuts for writing code quickly. Rstudio comes standard with many such shortcuts.

Personally, I R scripts using the [Sublime Text](https://www.sublimetext.com/) editor with the [R-Box package](https://packagecontrol.io/packages/R-Box) installed. Sublime has a nice system for installing supplemental packages and editing custom keyboard shortcuts for any language you frequently use. If you use Sublime already, feel free to [pilfer from my custom settings](https://github.com/mikedecr/sublime-user-folder).

Script files should begin with some description of the script. You can include comments (text that will not be executed as R commands) after the `#` symbol. For example, your script file for this lesson might contain some comments at the top like...

```{r}
# ------------------------------------------------------------
#  PS 811: statistical computing for political science
#  Lesson 1: Basics of R
# ------------------------------------------------------------
```

Comments are great for describing what code is doing, planning an analysis, writing notes to yourself, and so on. Comments are great for *pseudocode*, which are notes to yourself that "translate" what code is doing into English. We will see some examples of this as the course progresses.

At the top of my script files, I typically include some code that sets up my project:

- create subdirectories for storing output (we'll cover this later)
- load relevant packages
- set other project-wide options (graphics themes, graphics colors, any other things I want to store)

Although a script file can be imperfect while a project is being developed, a well-written script file for a finished project should be organized, easy to read, and run from top to bottom without any errors. This is important for ensuring that you can retrace the steps of your analysis.

We should save this file. Navigate to your `ps811` folder on your computer (which you should have...), create a subfolder for R, and then within the R folder, create another "lessons" folder. Save this document in `ps811/R/lessons/`. (This syntax represents folder pathways in your computer's file system. We'll be seeing more of this later.)




# Executing commands

Just like Stata, the R interface is a REPL---that is, Read-Evaluate-Print Loop. That means R processes commands one at a time without the need to pre-compile any code.

Just to demonstrate some basic R behavior, let's run a few commands.

First, R works as a calculator. It can handle mathematical expressions. Paste or type the following lines of code DIRECTLY into the console.

```{r, eval = FALSE}
1 + 1
2 + 2
100 * 2
500 / 4
```

You will notice that the results of each calculation will print beside a little `[1]`. Ignore this for now; we will explain it later.

Now take the above block of code and paste the commands into your script file. Try to run the commands from the script file using a keyboard shortcut. Most computers and interfaces use `super + enter`, where `super` refers to `Ctrl` on PCs or `Cmd` on Macs. Windows machines may use a different shortcut, such as `Ctrl + R`. Take this opportunity to look up the appropriate keyboard shortcut on your own, *before coming to lecture!* :-)




# Variables

We don't usually manipulate mathematical expressions this atomically in R. Instead we treat data as variables. Just as how in math the expression $x + 4$ can take different values depending on the value of $x$, we can do similar things with R. 

First, we'll "assign" a value to a variable using the assignment operator `<-`. The `<-` is a combination of a less-than sign `<` and a hyphen `-`.

For example,

```{r}
x <- 5
```

Now the variable `x` has the value of `5`, which is to say, `x` and `5` now mean the same thing! 

We can display the contents of any object by simply typing the object name. Print out `x`...

```{r}
x
```

...and we get back a `5`. That is to say, R "evaluated" the object called `x` and the result is simply equal to 5.

Do some math with `x`...

```{r}
x + 4
```

You can read the `<-` operator as "gets." A left-hand side object "gets" the results of whatever operation is on the right-hand side. So in the above example, `x` "gets" the value of 5. For simple expressions, `<-` can mean "equals," but as we begin working with more complex objects (such as the results of a statistical model), saying "equals" in your head becomes a little more difficult to justify.


# More variables: vectors

We can assign a series of values to a variable. One way to do this in R is the `c()` function. The `c()` function will bind several elements into one variable, as long as the elements can be coerced to be the same data type (numeric, factor, string, etc). 

```{r}
y <- c(2, 4, 6)
y
```

If you wrap an assignment inside of parentheses, the result will print at the same time that values are assigned.

```{r}
(y <- c(2, 4, 6))
```

We can use multi-element variables to do math on the entire vector at once. Just as we could do real math with a vector...

$\begin{align} 2 \cdot \begin{bmatrix} 2 \\ 4 \\ 6 \end{bmatrix} = \begin{bmatrix} 4 \\ 8 \\ 12 \end{bmatrix} \end{align}$

we can also do similar things in R.

```{r}
2 * y
y * y
```




# Everything is an Object

In R, everything is an object. I can store an arbitrary value as a variable, which is an object. A text string can be an object. An entire dataset. A variable within a dataset can be thought of as an object within another object. It's all objects. This makes R very flexible, although some object manipulations are obviously out of bounds (can't add `4 + "fish"`, for example).





# Indexing

It is possible to access the elements of a variable using *indexing* notation. R uses square brackets to select a given element in a variable. Using the variable `y` from above, what are the first, second, and third elements?

```{r}
y
y[1]
y[2]
y[3]
```

Indexing notation is why the console prints a little `[1]` next to all results. It is indicating that the adjacent element is the first element of the results. This becomes clearer if we were to print a long vector with many more elements---for example, 100 repetitions of the same data.

```{r}
rep("hello", 100)
```

We could have two (or higher) dimensional objects. Let's make some simple two-dimensional objects:

```{r}
tall_m <- rbind(c(1, 2), 
                c(3, 4), 
                c(5, 6))
tall_m
```

(Notice how `rbind()` binds vectors together as rows.)

```{r}
wide_m <- cbind(c(1, 2), 
                c(3, 4), 
                c(5, 6))
wide_m
```

(And `cbind()` binds vectors as columns.)

We can still use indexing notation to access the data within these objects. We use the notation `object[a, b]`, where `a` indicates the row number and `b` indicates the column number.

```{r}
tall_m[2, 2]
wide_m[1, 3]
```

If we specify a row but don't specify a column, R returns every column from the specified row. Here we specify the row `1` but don't specify a column. 

```{r}
wide_m[1, ]
```

And if we don't specify a row, R grabs every row. Here we leave the row unspecified but grab the second column.

```{r}
tall_m[ , 2]
```

Even though `tall_m[ , 2]` is the second *column* of `tall_m`, the results don't print as a vertical column. Why? Because once R evaluates `tall_m[ , 2]`, the results are just another object. It's nothing more than a vector floating there. R no longer remembers that it comes from `tall_m`. You could use that vector for more stuff; indeed, as far as R is concerned, `tall_m[ , 2]` is exactly equivalent to a vector `c(2, 4, 6)`.

*This is the kind of flexibility that is valuable in R.* You can ask R to evaluate some complex thing, and its results become available to you as just another vector that you can manipulate further. This allows you to sew together a complicated series of commands and, as long as you don't trip some kind of error, it just works. 

## A note about indexing

Although some languages are "zero-indexed" (meaning the first element of a variable is index position 0), R is "one-indexed." This makes more sense for statistical purposes, but it may be different from other languages you have seen (for example C). Calling the 0'th element of a variable does not throw an error, however. Go figure.

```{r}
y[0]
```

**Another important note:** Although it is important that you understand the intuition of indexing for thinking about how R works, this kind of *explicit* indexing is not something you will do much when we move to the `tidyverse`. Indexing remains important for several reasons though. First, it has useful mathematical parallels, where $y_{i}$ is analogous to `y[i]`. This sometimes comes in handy for dealing with the results from statistical models. Additionally, you will encounter it when searching through message boards for R help, especially when you see someone do some kind of *logical selection*. `tidyverse` functions implicitly use indexing by logical selection all the time. What does "logical selection" mean, exactly? Well...


# Logic

Logic as a concept in programming is less daunting than it sounds. At it's core, what we're doing is dealing with is statements that evaluate to either `TRUE` or `FALSE`j. An example to illustrate what I mean: we'll make a vector.

```{r}
(g <- 1:10)
```

We can ask R about things that are true and false about the values in the vector. For example, are the values greater than 5?

```{r}
g > 5
```

The statement `g > 5` is a "logical," meaning that its underlying meaning is fundamentally `TRUE` or `FALSE`. R asks if `g` is greater than 5, and since `g` is a vector, and R returns a vector of logicals, each element corresponding to the original elements in `g`. 

We can do this kind of thing with several operators. Let's see them in practice.

```{r}
# g "is equal to" 5
g == 5

# g "is greater than" 5
g > 5

# g "is less than" 5
g < 5

# g "is greater than or equal to" 5
g >= 5

# g "is less than or equal to" 5
g <= 5
```

Relating this back to index notation, you will probably see R users online using indexing and logical evaluation to select observations from a dataset. For example, let's say I want to multiply `g` by 10.

```{r}
g * 10
```

And now let's say that I only want to do this for values of `g` less than 4. First I can limit my selection of `g` to the values I want...

```{r}
g[g < 4]
```

...which is to say, "give me the elements of `g` where `g` is less than 4" (or more literally, "give me the elements of `g` where the statement `g < 4` evaluates to `TRUE`").

Once we have these elements, we do the operation.

```{r}
g[g < 4] * 10
```

This seems a little abstract right now, but here's how you may see others do this online. Let's say that I have a dataset of World Health Organization data, and I want to look only at the European data. You might see someone online limit the data like so.

```{r, eval = FALSE}
who[region == "Europe", ]
```

This block of code would read as, "give me the `who` object, but only the rows where `region` is `"Europe"`." (Or, again more literally, give me the `who` object, but only the rows where the statement `region == "Europe"` evaluates to `TRUE`). The `tidyverse` uses other tools to do this selection. Cases are still kept using logical syntax (which is very useful), but you don't have to think so hard about index positions evaluating to `TRUE`. It ends up being much more intuitive.


# Data types

We have hinted so far that there are a few different types of data in R. 

- Logical: `TRUE`s and `FALSE`s.
- Numeric: including integers and doubles
- Strings: text strings that are contained in `"quotes"`. R calls these "character" type variables.
- Factors: ordered categories with text labels

Factors require some explanation, because they are somewhat like numbers, but also somewhat like text strings, just like in Stata. They are like text strings because they have text labels and you can't do math with them. But they are like numbers because you can put them in order. Put another way, factors are *ordered categories* that have textual metadata. You can interact with them as text strings, but they are stored in the computer as numbers to conserve memory. As a result, factors are really only good for variables with finite categories, such as a 1-to-5 Likert scale.

It is possible to coerce data from type to another, which follows some intuitive rules that we can cover in future lessons.

Note: data types are different from *object classes*. There are many classes of objects that can have different attributes. We'll see these more in future lessons (but examples include matrices, data frames, tables, lists, tibbles, lm objects, and so on).


# Missing data

Vectors might contain missing data. The missing data code in R is `NA`, without quotes. 

Missing data take the same data type as the vector in which they are located. For example:

```{r}
h <- c(1, 2, NA, 4)
# what data type is h?
str(h)
```

By placing `NA` inside a numeric vector, what we've told R is that we know that the missing data is numeric, we just don't know what the number is. If some function requires that we know every value, it will probably fail. Try the following.

```{r}
mean(h)
```

Notice that this doesn't cause an *error*. Instead, the result is a missing value. What this means is, we know that there *should* be a numeric mean (which is why there is no error), we just don't know what the mean is because we don't know what all of `h` is. When we want to calculate this value irrespective of the missing values, we often need to tell R to skip over missing values.

```{r}
mean(h, na.rm = TRUE)
```

Many functions have `na.rm` ("remove `NA`") arguments that can be flipped on, such as `sum()`, `sd()`, and so on. 



# Functions

Although you can perform simple operations on data in R (adding, multiplying, and so on), these get tedious for complex tasks. Sequences of operations can be simplified as functions. We have already seen some examples of functions, such as `c()` for making vectors. 

There are three things you need to use a function.

1. The function name itself. Self-explanatory
2. Parentheses. This tells R that the object name is meant to be a function.
3. Arguments inside the parentheses. Technically these can be optional, depending on the function and its default behaviors. Arguments can be data that you pass to the function (as inputs), settings that you modify, and so on.

Here are some common, helpful functions. 

```{r}
# 10 thousand random samples from a normal distribution
x <- rnorm(n = 10000, mean = 0, sd = 1)

# sum
sum(x) 
# number of elements in an object
length(x) 
# mean
mean(x) 
# variance
var(x) 
# standard deviation
sd(x) 
```

It is fairly easy to write your own functions in R. We will come back to that in a later lesson.

# Help files

Get help on any function using `?function_name` or `help(function_name)`.


# External Packages (for non-base functions)

Base R only contains a small number of functions. Most analyses require more complicated tools that are not standard with R. For these tasks, there are hundreds of packages available for download. 

Official R packages are hosted on CRAN and can be installed with code. For example, the following code will install the `tidyverse` package. Because the package depends on other packages, all required packages will be downloaded if not already on your system. As a result, this command would take a while to execute (but you should execute it...we will use this package in class).

```{r, eval = FALSE}
install.packages("tidyverse")
```





# Comparing and contrasting R and Stata

As we continue these lessons, you will see more about how these languages are similar and different. There are definitely *some* similarities. The REPL interface (commands are evaluated instantly and results displayed in a console) is a big one. This means you don't have to compile an entire file of code before you can run it. Yay! 

The differences between R and Stata have benefits and drawbacks. Here is some rapid-fire accounting of some differences. 

R is free and open source. 

- Pro: When you lose your university access license to Stata (which you will, eventually), you can still use R.
- Con: Some of the stuff in R may lower quality than the stuff in Stata. Granted, most of the stuff in R you use works just as well as Stata, but there is really nothing stopping some jerk from writing some sloppy code and putting it out there. Wisdom of the crowds generally holds though: if an R tool is popular, you can count on it to be reliable. There are *lots* of smart people using and constantly improving R!


R is a fully formed programming language.

- Pro: R makes it very easy to directly access data as vectors, matrices, and dataframes with a coherent and vertically integrated programming syntax.
- Pro: R operates with *functions* rather than mere *commands*. In R, if I had the functions `f()`, `g()`, and `h()`, I could write `f(g(h(x)))` in one line of code and it just works.
- Con: This makes R a little tougher to learn at first for those with less computing experience.


R is object-oriented.

- Pro: this lets R be very flexible.
- Pro: You can load and manipulate multiple datasets at once without being confined to one data table. 
- Con: This makes accessing variables within datasets more difficult, because you have to specify *which* dataset to look inside of. We will cover this in the future. Luckily, the `tidyverse` provides tools for making this easier.
- Con: This also makes R slower than Stata, generally speaking. This is because R has to check to make sure that the commands you want to run make sense (checking data types, sizes of objects, and so on). You generally won't notice this unless you work with larger datasets. When your dataset is truly massive, there are ways to use R as a front-end to interact with other programming languages, such as `RSQL` to talk to SQL from R.


R's interface is less graphical than Stata. It's all about the code.

- Pro: This makes replication easier (or, harder to mess up) in R, because there is less dependence on pointing-and-clicking to create analysis and graphics. 
- Con: For newcomers who are used to seeing their data in front of them as a spreadsheet, this makes R more psychologically difficult to pick up than Stata.
- Con: R syntax is more "programmy" and less English-seeming. The drawback of this is that it is complicated *at first*. The benefit of this is that it is simpler in the long run, because the rules of the syntax impose long-run structure and coherence in the R language.



# Moving on

If you have made it this far, take a break! 

I want to remind you that future lessons will be far less abstract than this one. Many concepts in this lesson are *important* in the sense that you will see them again during your R career, but they are not all *essential* for surviving this course. Future lessons will be far more concrete and dataset-driven.

Continue with the next lesson: [Data Manipulation](811/811-data)








